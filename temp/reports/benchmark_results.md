# Performance Benchmarks

## Comparison of Logging Performance

Comprehensive benchmarks were conducted to evaluate the performance characteristics of the `prismalog` package across different concurrency models. These benchmarks were compared to Python's standard logging library.

### Test Configuration

| Test Type        | Configuration           | Total Messages |
|------------------|-------------------------|----------------|
| Multiprocessing  | 3 processes             | ~33,000        |
| Multithreading   | 4 threads               | ~12,400        |
| Mixed Mode       | 3 processes × 2 threads | ~60,000        |
| Standard Logging | 4 threads               | ~12,400        |

### Results Summary

| Test Type        | Msgs/sec  | Exec Time (s) | DEBUG (ms) | INFO (ms) | WARNING (ms) | ERROR (ms) | Memory Δ (MB) | Log Size (MB)|
|------------------|-----------|---------------|------------|-----------|--------------|------------|---------------|--------------|
| Multiprocessing  | 29,144.24 | 3.19          | 0.10       | 0.10      | 0.10         | 0.09       | 0.27          | 9.18         |
| Multithreading   | 10,171.55 | 12.19         | 0.41       | 0.39      | 0.38         | 0.36       | 0.60          | 11.18        |
| Mixed Mode       | 22,888.03 | 8.13          | 0.28       | 0.26      | 0.25         | 0.24       | 0.40          | 17.12        |
| Standard Logging | 10,268.83 | 1.21          | 0.54       | 0.32      | 0.31         | 0.25       | 0.56          | 1.05         |

### Key Observations

1. **Concurrency Models**:
   - The highest throughput was observed in the multiprocessing model, with nearly 30,000 messages processed per second.
   - A good balance of throughput and resource utilization was achieved in the mixed mode (processes with threads).
   - The lowest throughput was recorded in the pure threading model, though it remains suitable for many applications.

2. **Latency**:
   - The lowest per-message latency (0.10-0.11ms) was provided by multiprocessing.
   - Higher latency (0.37-0.45ms) was observed in thread-based approaches.
   - Standard logging exhibited varying latency across log levels (0.23-0.51ms).

3. **Resource Usage**:
   - Minimal memory consumption (0.27-0.68MB) was observed across all approaches.
   - Log file sizes varied based on the total number of messages processed.
   - More compact log files were generated by standard logging.

### Feature Advantages Over Standard Logging

While performance benchmarks provide valuable insights, several important features are offered by `prismalog` that are not available in the standard logging library:

1. **Color-coded Console Output**:
   - Syntax highlighting for log messages is applied automatically based on their severity level.
   - Customizable color schemes are supported for different environments.
   - Readability is improved by visually distinguishing between different message types.

2. **Special Critical Message Handling**:
   - Application termination on critical errors is optionally supported.
   - Configurable callbacks for critical message events are provided.
   - Stack trace preservation is ensured for critical failures.

3. **Advanced Configuration**:
   - Environment variable support is included, with sensible defaults and multiple fallback patterns.
   - Command-line argument integration is supported, with automatic help generation.
   - Configuration file support (YAML) is provided, with automatic detection.

4. **Developer Experience Enhancements**:
   - A simplified API is offered for common logging patterns.
   - Context managers are provided for temporary logging level changes.
   - Convenient decorators are included for function entry/exit logging.

### Choosing the Right Approach

- **Multiprocessing** should be used for maximum throughput in CPU-bound logging applications.
- **Threading** is recommended for I/O-bound applications or when shared memory is required.
- **Mixed Mode** is suitable for complex applications that benefit from both process isolation and thread efficiency.
- **Additional Features** should be considered when advanced logging capabilities, such as color coding and special critical message handling, are more important than raw performance.

These benchmarks were conducted on a modern multi-core system running Linux. Variations in performance may be observed based on system specifications, file system performance, and application characteristics.
